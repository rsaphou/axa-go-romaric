use serde::{Deserialize, Serialize};
use chrono::{DateTime, Local, TimeZone};
use pdk::cache::{CacheError,Cache};
use pdk::logger;

#[derive(Serialize, Deserialize,Debug)]
pub struct SPEToken {
    pub access_token_expiration_time: i64,
    pub access_token: String,
    pub refresh_token: String
}

impl SPEToken {
    /// Given the current time check, if the value was cached in the current cache window.
    pub fn has_expired(&self, now: &DateTime<Local>) -> bool {
        Local.timestamp_opt(self.access_token_expiration_time as i64, 0).unwrap().lt(now)
    }
}


pub enum ReadingCacheError {
    CacheMiss(String),
    CacheExpired(),
    Deserialize(String, serde_json::Error),
    Cache(CacheError)
}

pub enum SavingCacheError {
    Serialization(serde_json::Error),
    Cache(CacheError)
}

pub async fn get_token_from_cache(
    cache: &impl Cache,
) -> Result<SPEToken, ReadingCacheError> {
    
    // Get the time in the current timezone.
    let now = Local::now();

    // Read the value from the cache
    let cached = cache
        .get("SPE-token")
        .ok_or_else(|| ReadingCacheError::CacheMiss("SPE-token".to_string()))?;


    // Deserialize the retrieved data
    let deserialized: SPEToken = serde_json::from_slice(cached.as_slice())
        .map_err(|e| ReadingCacheError::Deserialize("SPE-token".to_string(), e))?;

    // Check the logical expiration of the cached value
    if deserialized.has_expired(&now) {
        logger::info!("cached Token expired at : {:#?}",Local.timestamp_opt( deserialized.access_token_expiration_time as i64, 0).unwrap());
        return Err(ReadingCacheError::CacheExpired());
    }
    Ok(deserialized)
}

pub async fn save_token_to_cache(
    cache: &impl Cache,
    token: &SPEToken,
    replace: bool,
) -> Result<(), SavingCacheError> {
    if replace == true {
        logger::debug!("replace flag enabled, deleting cache entry");
        cache.delete("SPE-token");
    }
    let serialized = serde_json::to_vec(&token).map_err(SavingCacheError::Serialization)?;
        
    // Saves the serialized object
    cache
        .save("SPE-token", serialized)
        .map_err(SavingCacheError::Cache)?;
    Ok(())
}