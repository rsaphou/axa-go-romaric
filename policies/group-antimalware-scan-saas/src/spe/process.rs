use pdk::logger;
use chrono::{Local, TimeZone};

use crate::spe::token::{get_token_from_cache, save_token_to_cache, SPEToken, SavingCacheError,ReadingCacheError};
use crate::spe::calls::{get_spe_token,scan_file_by_spez,scan_file_by_spe};
use crate::spe::scan::{ScanningError,SPECallError};
use pdk::hl::*;
use bytes::Bytes;
use crate::generated::config::Config;
use pdk::cache::Cache;

pub async fn process_attachment_scanning(
    body_state: RequestBodyState,
    content_type : String,
    config: &Config,
    cache: &impl Cache,
    client: HttpClient) -> Result<(), ScanningError> {
    match get_token_from_cache_or_spe(config, cache, &client).await {
        Ok(token) => {
            logger::debug!("Token retrieved ");
            match scan_file_by_spe(config,content_type,&body_state,&token,client).await{
                Ok(result) => {
                    logger::debug!("Scan result retrieved from the server : {:#?}", result);
                    Ok(())
                }
                Err(ScanningError::ServerError(x))=> {
                    logger::debug!("Scan error from the server : {:#?}", x);
                    return Err(ScanningError::ServerError(x))
                }
                Err(ScanningError::Infected(x))=> {
                    logger::debug!("Infected file detected : {:#?}", x);
                    return Err(ScanningError::Infected(x))
                }
            }
        }
        Err(SPECallError::ServerError(x))  => {
            logger::error!("error : {x}");
            logger::error!("Could not get token, aborting");
            return Err(ScanningError::ServerError(x));
        }
    }
} 
pub async fn process_attachment_scanningz(
    body_bytes: Vec<u8>,
    content_type : String,
    config: &Config,
    cache: &impl Cache,
    client: &HttpClient) -> Result<(), ScanningError> {
    match get_token_from_cache_or_spe(config, cache, &client).await {
        Ok(token) => {
            logger::debug!("Token retrieved ");
            match scan_file_by_spez(config,content_type,&body_bytes,&token,client).await{
                Ok(result) => {
                    logger::debug!("Scan result retrieved from the server : {:#?}", result);
                    Ok(())
                }
                Err(ScanningError::ServerError(x))=> {
                    logger::debug!("Scan error from the server : {:#?}", x);
                    return Err(ScanningError::ServerError(x))
                }
                Err(ScanningError::Infected(x))=> {
                    logger::debug!("Infected file detected : {:#?}", x);
                    return Err(ScanningError::Infected(x))
                }
            }
        }
        Err(SPECallError::ServerError(x))  => {
            logger::error!("error : {x}");
            logger::error!("Could not get token, aborting");
            return Err(ScanningError::ServerError(x));
        }
    }
} 

pub async fn get_token_from_cache_or_spe(
    config: &Config,
    cache: &impl Cache,
    client: &HttpClient) -> Result<SPEToken, SPECallError> {

    match get_token_from_cache(cache).await {
        Ok(token) => {
            logger::debug!("Token retrieved from the cache. Expiring : {:#?}", Local.timestamp_opt( token.access_token_expiration_time as i64, 0).unwrap());
            Ok(token)
        }
        Err(ReadingCacheError::CacheMiss(key)) =>{
            logger::debug!("No entry in the cache for key : {:#?}", key);
            match get_spe_token(config, client).await {
                Ok(token) => {
                    logger::debug!("Token retrieved from the server. Expiring : {:#?}", Local.timestamp_opt( token.access_token_expiration_time as i64, 0).unwrap());
                    match save_token_to_cache(cache, &token, false).await{
                        Ok(()) => Ok(token),
                        Err(SavingCacheError::Serialization(..)) | Err(SavingCacheError::Cache(_)) =>{
                            logger::error!("Failed to correctly save token to cache proceeding with live token, Error");
                            Ok(token)
                        } 
                    }
                }
                Err(SPECallError::ServerError(x)) => return Err(SPECallError::ServerError(x))
            }
        }
        Err(ReadingCacheError::CacheExpired()) | Err(ReadingCacheError::Deserialize(..)) | Err(ReadingCacheError::Cache(_)) =>{
            match get_spe_token(config, client).await {
                Ok(token) => {
                    logger::debug!("Token retrieved from the server. Expiring : {:#?}", token.access_token_expiration_time);
                    match save_token_to_cache(cache, &token, true).await{
                        Ok(()) => Ok(token),
                        Err(SavingCacheError::Serialization(..)) | Err(SavingCacheError::Cache(_)) =>{
                            logger::error!("Failed to correctly save token to cache proceeding with live token, Error");
                            Ok(token)
                        } 
                    }
                }
                Err(SPECallError::ServerError(x)) => return Err(SPECallError::ServerError(x))
            }
        }
    }
}