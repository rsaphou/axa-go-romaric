use std::str::FromStr;
mod generated;
mod spe;
use pdk::cache::{Cache, CacheBuilder};
use anyhow::{anyhow, Result};
use pdk::hl::*;
use pdk::logger;
use json::object;
use multer::Multipart;
use futures::io::AsyncReadExt;
use std::io::Cursor;
use crate::generated::config::Config;
use crate::spe::process::{process_attachment_scanning,process_attachment_scanningz};
use crate::spe::scan::{ScanningError};
use bytes::Bytes;
use futures::stream::Stream;
use std::convert::Infallible;
use futures::stream::once;
use std::fmt;
use serde::{Deserialize, Serialize};

use serde_json::json;
extern crate serde_json;
use serde_json::{Value};

use pdk::metadata::Metadata;
use chrono::{DateTime, Local, TimeZone};
use pdk::jwt::JWTClaimsParser;
use pdk::jwt::TokenProvider;
use regex::Regex;
use url::Url;

fn vec_u8_to_int(vec: Vec<u8>) -> i64 {
    let mut num : i64 = 0;
    let mut base : i64 = 1;
    if vec.len() > 0 {
        for i in 0..(vec.len()-1)
        {
            num = num + (base * (vec[i] as i64));
            base = base * 256;
            // num = base.pow(i.try_into().unwrap()) + (x[i] as u32);
        }
    }else{};
    num
}

async fn request_filter(request_state: RequestState, config: &Config, cache: &impl Cache, client: HttpClient, service: &Service, metadata: &Metadata, stream: StreamProperties) -> Flow<String>{
    let headers_state = request_state.into_headers_state().await;
    let content_type = headers_state.handler().header("content-type").unwrap_or_default();
    let contclone = content_type.clone();
    let mut contents: Vec<&str> = contclone.split(";").collect();
    logger::info!("contents : {:#?}", contents);

    
    let mut client_id: Option<String> = Default::default();
    let mut scope: Option<String> = Default::default();
    let mut audience: Option<String> = Default::default();
    let mut issuer: Option<String> = Default::default();
    
    let auth_header = headers_state.handler().header("authorization").unwrap_or_default();
    if !auth_header.is_empty() {
        let token = TokenProvider::bearer(headers_state.handler());
        if token.is_err() {
            
        } else {
            
            let parsed_claims = JWTClaimsParser::parse(token.unwrap());
            
            if parsed_claims.is_err() {
                
            } else {
                let claims = parsed_claims.unwrap();
                
                client_id = claims.get_claim("client_id");
                scope = claims.get_claim("scope");
                audience = claims.get_claim("aud");
                issuer = claims.get_claim("iss");
            }
        }
    }else {
            
        }
    
    let start_time: DateTime<Local> = Local::now();
    let formatted_start_time = start_time.format("%Y-%m-%d %H:%M:%S%.6f").to_string();
    let path = headers_state.path();
    let url = headers_state.authority();
    let method = headers_state.method();
    let proto = headers_state.handler().header("x-forwarded-proto").unwrap_or_default();
    let modified_url = format!("{}://{}", proto, url);
    let request_content_type = headers_state.handler().header("content-type").unwrap_or_default(); 
    let user_agent = headers_state.handler().header("user-agent").unwrap_or_default();
    let mut query_string = String::new();
    if let Some(index) = path.find('?'){
        query_string = path[index + 1..].to_string();
    }
    let mut version: String = String::new();
    let mut label: String = String::new();
    println!("{:#?}",metadata);
    let label_version = metadata.api_metadata.version.clone().unwrap_or_default();
    let re = Regex::new(r"^[a-zA-Z]+-[a-zA-Z]+-[a-zA-Z]+-v\d").unwrap();
    if re.is_match(&label_version) && !label_version.is_empty() {
        let mut parts = label_version.split('-').collect::<Vec<&str>>();
        version = parts.pop().unwrap_or("").to_string();
        label = format!("{}-{}-{}", parts[0], parts[1], parts[2]);
    }else{
       
    }
    
	let tls_version = String::from_utf8(stream.read_property(&["connection", "tls_version"]).unwrap_or_default()).unwrap_or_default();
    let destination_address = String::from_utf8(stream.read_property(&["destination", "address"]).unwrap_or_default()).unwrap_or_default();
    let destination_port = String::from_utf8(stream.read_property(&["destination", "port"]).unwrap_or_default()).unwrap_or_default();
    let source_address = String::from_utf8(stream.read_property(&["source", "address"]).unwrap_or_default()).unwrap_or_default();
    let source_port = String::from_utf8(stream.read_property(&["source", "port"]).unwrap_or_default()).unwrap_or_default();
    let trace_id = String::from_utf8(stream.read_property(&["request", "id"]).unwrap_or_default()).unwrap_or_default();
    let upstream_address = String::from_utf8(stream.read_property(&["upstream", "address"]).unwrap_or_default()).unwrap_or_default();
    let upstream_port = String::from_utf8(stream.read_property(&["upstream", "port"]).unwrap_or_default()).unwrap_or_default();

    let upst = (stream.read_property(&["upstream","remote_address"]).unwrap_or_default());
    println! ("upst : {:?}", upst);

    let inbound_attributes = json!({
        "request_path" : String::from_utf8(stream.read_property(&["request", "path"]).unwrap_or_default()).unwrap_or_default(),
        "request_url_path" : String::from_utf8(stream.read_property(&["request", "url_path"]).unwrap_or_default()).unwrap_or_default(),
        "request_host" : String::from_utf8(stream.read_property(&["request", "host"]).unwrap_or_default()).unwrap_or_default(),
        "request_scheme" : String::from_utf8(stream.read_property(&["request", "scheme"]).unwrap_or_default()).unwrap_or_default(),
        "request_method" : String::from_utf8(stream.read_property(&["request", "method"]).unwrap_or_default()).unwrap_or_default(),
        "request_headers" : String::from_utf8(stream.read_property(&["request", "headers"]).unwrap_or_default()).unwrap_or_default(),
        "request_referer" : String::from_utf8(stream.read_property(&["request", "referer"]).unwrap_or_default()).unwrap_or_default(),
        "request_useragent" : String::from_utf8(stream.read_property(&["request", "useragent"]).unwrap_or_default()).unwrap_or_default(),
        "request_time" : (stream.read_property(&["request", "time"]).unwrap_or_default()),
        "request_id" : String::from_utf8(stream.read_property(&["request", "id"]).unwrap_or_default()).unwrap_or_default(),
        "request_protocol" : String::from_utf8(stream.read_property(&["request", "protocol"]).unwrap_or_default()).unwrap_or_default(),
        "request_query" : String::from_utf8(stream.read_property(&["request", "query"]).unwrap_or_default()).unwrap_or_default(),
        
        "source_address" : String::from_utf8(stream.read_property(&["source", "address"]).unwrap_or_default()).unwrap_or_default(),
        "source_port" : vec_u8_to_int(stream.read_property(&["source", "port"]).unwrap_or_default()),
        
        "destination_address" : String::from_utf8(stream.read_property(&["destination", "address"]).unwrap_or_default()).unwrap_or_default(),
        "destination_port" : vec_u8_to_int(stream.read_property(&["destination", "port"]).unwrap_or_default()),
        
        "connection_id" : vec_u8_to_int(stream.read_property(&["connection", "id"]).unwrap_or_default()),
        "connection_mtls" : (stream.read_property(&["connection", "mtls"]).unwrap_or_default()[0] != 0),
        "connection_requested_server_name" : String::from_utf8(stream.read_property(&["connection", "requested_server_name"]).unwrap_or_default()).unwrap_or_default(),
        "connection_tls_version" : String::from_utf8(stream.read_property(&["connection", "tls_version"]).unwrap_or_default()).unwrap_or_default(),
        "connection_subject_local_certificate" : String::from_utf8(stream.read_property(&["connection", "subject_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_subject_peer_certificate" : String::from_utf8(stream.read_property(&["connection", "subject_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_dns_san_local_certificate" : String::from_utf8(stream.read_property(&["connection", "dns_san_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_dns_san_peer_certificate" : String::from_utf8(stream.read_property(&["connection", "dns_san_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_uri_san_local_certificate" : String::from_utf8(stream.read_property(&["connection", "uri_san_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_uri_san_peer_certificate" : String::from_utf8(stream.read_property(&["connection", "uri_san_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "connection_sha256_peer_certificate_digest" : String::from_utf8(stream.read_property(&["connection", "sha256_peer_certificate_digest"]).unwrap_or_default()).unwrap_or_default(),
        "connection_transport_failure_reason" : String::from_utf8(stream.read_property(&["connection", "transport_failure_reason"]).unwrap_or_default()).unwrap_or_default()
    });
    println!("{:#?}",inbound_attributes);
    
    let url = Url::parse(&modified_url).unwrap();
    let port = url.port_or_known_default().unwrap();

    let request_data_value = json!({ 
        "http.request.referrer": modified_url,
        //"url.domain": url,
        //"url.path": path,
        //"http.request.method": method,
        //"http.response.mime_type": request_content_type,
        "client.user.id": client_id,
        "url.query": query_string,
        //"api.id": metadata.api_metadata.id.clone().unwrap(),
        //"api.name": metadata.api_metadata.name.clone().unwrap(),
        //"api.label": metadata.api_metadata.version.clone().unwrap(),
        "api.label": label,
        //"api.version": version,
        //"user_agent.original": user_agent,
        "event.start": formatted_start_time,
        //"http.request.body.bytes": body_bytes,
        "client.user.jwt.scope": scope,
        "client.user.jwt.audience": audience,
        "client.user.jwt.issuer": issuer,
		"tls.version": tls_version,
        "destination.address": destination_address,
        "destination.port": destination_port,
        "source.address": source_address,
        "source.port": source_port,
        "traceId": trace_id,
        "port":port
});

    
    //TODO Value to be taken from the configuration 
    let list_external_port: Vec<String> = vec!["8081".into(), "8082".into(), "8083".into()];
    let v_destinaltion_port =  vec_u8_to_int(stream.read_property(&["destination", "port"]).unwrap_or_default());
    
    if list_external_port.contains(&v_destinaltion_port.to_string())
    {
        logger::debug!("Skipping the scaning for internal port {}", v_destinaltion_port.to_string().as_str());
        Flow::Continue(request_data_value.to_string())
    }

    else
    {
        logger::debug!("Start the scaning for external port {}", v_destinaltion_port.to_string().as_str());
        if contents.contains(&"application/octet-stream") | contents.contains(&"multipart/form-data") {
            let bounds: Vec<_> = contents.iter().copied().filter(|&el| el.contains("boundary")).collect();
            let boundary = bounds[0].split("=").collect::<Vec<_>>()[1];
            println!("cont: {:?}", boundary);
            let body_state = headers_state.into_body_state().await;
            let bods = body_state.handler().body();
            // let (stream, boun) = get_byte_stream_from_somewhere(bods, &boundary).await;
            // // let mut cursor = Cursor::new(body_state.handler().body());
            // let mut multipart = Multipart::new(stream, boun);
            // let x = proc(bods, &boundary,content_type.clone(),config, cache, client, service).await;
            // while let Some(mut field) = multipart.next_field().await? {
            //     // Get field name.
            //     let name = field.name();
            //     // Get the field's filename if provided in "Content-Disposition" header.
            //     let file_name = field.file_name();
        
            //     println!("Name: {:?}, File Name: {:?}", name, file_name);
        
            //     // Process the field data chunks e.g. store them in a file.
            //     while let Some(chunk) = field.chunk().await? {
            //         // Do something with field chunk.
            //         println!("Chunk: {:?}", chunk);
            //     }
            // }
            // logger::info!("Scanning payload as Content Type values: {content_type}");
            // Flow::Continue(())
            match proc(&bods, &boundary,content_type.clone(),config, cache, client, service).await{
                Ok(nod) => {
                    logger::info!("Scanning payload successful, proceeding with the request");
                    Flow::Continue(request_data_value.to_string())
                }
                Err(ScanningError::Infected(result)) =>{
                    logger::error!("Scanning detected an infected file : {:#?}", result);
                    let map = object!{
                        errorDescription: "Scanning detected an infected file, dropping the request"
                    };
                    Flow::Break(Response::new(409)
                    .with_headers(vec![("content-type".to_string(), "application/json".to_string())])
                    .with_body(map.dump().as_bytes()))
                }
                Err(ScanningError::ServerError(error)) =>{
                    let map = object!{
                        errorDescription: error 
                    };
                    logger::error!("Scanning Server returner unexpected error : {map}");
                    Flow::Break(Response::new(500)
                    .with_headers(vec![("content-type".to_string(), "application/json".to_string())])
                    .with_body(map.dump().as_bytes()))
                }
            }
        }
        else{
            logger::info!("Skipping scan, Content Type value: {content_type}");
            Flow::Continue(request_data_value.to_string())
        }
    }
}



async fn response_filter(response_state: ResponseState, _config: &Config, request_data: RequestData<String> , stream: StreamProperties) {
    let end_time: DateTime<Local> = Local::now();
    let formatted_end_time = end_time.format("%Y-%m-%d %H:%M:%S%.6f").to_string();
    let headers_state = response_state.into_headers_state().await;
    let response_content_type = headers_state.handler().header("content-type").unwrap_or_default();
    let response_status = headers_state.status_code();
   // let rate_limit = headers_state.handler().header("x-ratelimit-remaining").unwrap_or_default();
    let response_time = headers_state.handler().header("x-envoy-upstream-service-time").unwrap_or_default();
    let mut level_val;
    let mut response_error = String::new();
    let body_bytes;
    let mut body_content = String::new();
    let upstream_address = String::from_utf8(stream.read_property(&["upstream", "address"]).unwrap_or_default()).unwrap_or_default();
    let upstream_port = stream.read_property(&["upstream", "port"]).unwrap_or_default();
    // request.duration
    // request.size
    // request.total_size
    // response.code
    // response.code_details
    // response.flags
    // response.grpc_status
    // response.headers
    // response.trailers
    // response.size
    // response.total_size
    // response.backend_latency
    // connection.termination_details
    // upstream.address
    // upstream.port
    // upstream.tls_version
    // upstream.subject_local_certificate
    // upstream.subject_peer_certificate
    // upstream.dns_san_local_certificate
    // upstream.dns_san_peer_certificate
    // upstream.uri_san_local_certificate
    // upstream.uri_san_peer_certificate
    // upstream.sha256_peer_certificate_digest
    // upstream.local_address
    // upstream.transport_failure_reason
    // upstream.request_attempt_count
    // upstream.cx_pool_ready_duration
    // upstream.locality
    let outbound_attributes = json!({
        "request_duration" : (stream.read_property(&["request", "duration"]).unwrap_or_default()),
        "request_size" : vec_u8_to_int(stream.read_property(&["request", "size"]).unwrap_or_default()),
        "request_total_size" : vec_u8_to_int(stream.read_property(&["request", "total_size"]).unwrap_or_default()),
        "response_code" : vec_u8_to_int(stream.read_property(&["response", "code"]).unwrap_or_default()),
        "response_code_details" : String::from_utf8(stream.read_property(&["response", "code_details"]).unwrap_or_default()).unwrap_or_default(),
        "response_flags" : vec_u8_to_int(stream.read_property(&["response", "flags"]).unwrap_or_default()),
        "response_grpc_status" : vec_u8_to_int(stream.read_property(&["response", "grpc_status"]).unwrap_or_default()),
        "response_headers" : String::from_utf8(stream.read_property(&["response", "headers"]).unwrap_or_default()).unwrap_or_default(),
        "response_trailers" : String::from_utf8(stream.read_property(&["response", "trailers"]).unwrap_or_default()).unwrap_or_default(),
        "response_size" : vec_u8_to_int(stream.read_property(&["response", "size"]).unwrap_or_default()),
        "response_total_size" : vec_u8_to_int(stream.read_property(&["response", "total_size"]).unwrap_or_default()),
        "response_backend_latency" : (stream.read_property(&["response", "backend_latency"]).unwrap_or_default()),
        "connection_termination_details" : String::from_utf8(stream.read_property(&["connection", "termination_details"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_address" : String::from_utf8(stream.read_property(&["upstream", "address"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_port" : vec_u8_to_int(stream.read_property(&["upstream", "port"]).unwrap_or_default()),
        "upstream_tls_version" : String::from_utf8(stream.read_property(&["upstream", "tls_version"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_subject_local_certificate" : String::from_utf8(stream.read_property(&["upstream", "subject_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_subject_peer_certificate" : String::from_utf8(stream.read_property(&["upstream", "subject_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_dns_san_local_certificate" : String::from_utf8(stream.read_property(&["upstream", "dns_san_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_dns_san_peer_certificate" : String::from_utf8(stream.read_property(&["upstream", "dns_san_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_uri_san_local_certificate" : String::from_utf8(stream.read_property(&["upstream", "uri_san_local_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_uri_san_peer_certificate" : String::from_utf8(stream.read_property(&["upstream", "uri_san_peer_certificate"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_sha256_peer_certificate_digest" : String::from_utf8(stream.read_property(&["upstream", "sha256_peer_certificate_digest"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_local_address" : String::from_utf8(stream.read_property(&["upstream", "local_address"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_transport_failure_reason" : String::from_utf8(stream.read_property(&["upstream", "transport_failure_reason"]).unwrap_or_default()).unwrap_or_default(),
        "upstream_request_attempt_count" : vec_u8_to_int(stream.read_property(&["upstream", "request_attempt_count"]).unwrap_or_default()),
        "upstream_cx_pool_ready_duration" : (stream.read_property(&["upstream", "cx_pool_ready_duration"]).unwrap_or_default()),
        "upstream_locality": String::from_utf8(stream.read_property(&["upstream", "locality"]).unwrap_or_default()).unwrap_or_default()
    });
    println!("{:#?}",outbound_attributes);
    if !response_status.to_string().starts_with("20") {

        response_error = response_status.to_string();
        level_val = "ERROR";
        let response_body_state = headers_state.into_body_state().await;
        let get_body_bytes = response_body_state.handler().body().len();
        body_content = String::from_utf8_lossy(&response_body_state.handler().body()).to_string();
        body_bytes = get_body_bytes.to_string();
    }else{
        level_val = "INFO";
        let response_body_state = headers_state.into_body_state().await;
        let get_body_bytes = response_body_state.handler().body().len();
        body_bytes = get_body_bytes.to_string();
    }

    if let RequestData::Continue(request_data_value) = request_data {
      let log_data;
      if !response_status.to_string().starts_with("20"){
        level_val = "ERROR";
        log_data = json!({
            "http.response.mime_type": response_content_type,
            "http.response.status_code": response_status,
            "error.code": response_error,
            "http.response.body.bytes": body_bytes,
            "level": level_val,
            "upstream.address": upstream_address,
            "upstream.port": upstream_port,
            "http.response.body.content":body_content
         });
      }else{
        level_val = "INFO";
        log_data = json!({
            "http.response.mime_type": response_content_type,
            "http.response.status_code": response_status,
            "error.code": response_error,
            "event.end": formatted_end_time,
            "event.duration": response_time,
            "upstream.address": upstream_address,
            "upstream.port": upstream_port,
            "http.response.body.bytes": body_bytes,
            "level": level_val
         });
      }
      

    let request_data_string: Value = serde_json::from_str(&request_data_value).unwrap();
    let mut combined_json = request_data_string.as_object().unwrap().clone();

    for (key, value) in log_data.as_object().unwrap().iter() {
        combined_json.insert(key.clone(), value.clone());
    }
    let combined_json_value: Value = Value::Object(combined_json);

    // if level_val == "INFO"
    // { logger::info!("[accessLog] {}",combined_json_value); }
    // else
    // { logger::error!("[accessLog] {}",combined_json_value); }
    } else {
        return;
    };

    
}


#[entrypoint]
async fn configure(launcher: Launcher, Configuration(bytes): Configuration, cache_builder: CacheBuilder, metadata: Metadata) -> Result<()> {
    let config: Config = serde_json::from_slice(&bytes).map_err(|err| {
        anyhow!(
            "Failed to parse configuration '{}'. Cause: {}",
            String::from_utf8_lossy(&bytes),
            err
        )
    })?;
    //logger::debug!("--------------------Enter in Flex Gateway--------------------");
        // Create the cache
    let cache = cache_builder
    .new("SPE-token".to_string())
    .max_entries(1)
    .build();
    let service = Service::from(
        "spe-service",
        &config.namespace,
        Uri::from_str(&config.host)?,
    );
    let filter = on_request(|rs, client, stream| request_filter(rs, &config, &cache, client, &service, &metadata, stream)).on_response(|res,stream, request_data| {
        response_filter(res, &config, request_data, stream) 
    });
    launcher.launch(filter).await?;
    Ok(())
}


// Generate a byte stream and the boundary from somewhere e.g. server request body.
async fn get_byte_stream_from_somewhere(body: Vec<u8>, boundary:  &str) -> (impl Stream<Item = Result<Bytes, Infallible>>, & str) {
    // let data = "--X-BOUNDARY\r\nContent-Disposition: form-data; name=\"my_text_field\"\r\n\r\nabcd\r\n--X-BOUNDARY--\r\n";
    let stream = once(async move { Result::<Bytes, Infallible>::Ok(Bytes::from(body)) });
    (stream, boundary)
}

async fn proc<'a>(body: &'a Vec<u8>, boundary: &str, content_type : String, config: &Config, cache: &impl Cache, client: HttpClient, service: &Service) ->  Result<&'a Vec<u8>, ScanningError>{
    let my_string = String::from_utf8_lossy(body);
    // println!("Body: {:#?}", my_string);
    // Generate a byte stream and the boundary from somewhere e.g. server request body.
    let (stream, boun) = get_byte_stream_from_somewhere(body.clone(), &boundary).await;
    // let mut cursor = Cursor::new(body_state.handler().body());
    let mut multipart = Multipart::new(stream, boun);
    // Iterate over the fields, use `next_field()` to get the next field.
    while let Some(field) = multipart.next_field().await? {
        // Get field name.
        // let fields = field.clone()
        let name = field.name();
        // Get the field's filename if provided in "Content-Disposition" header.
        let file_name = field.file_name();
        let content_typers = field.content_type();
        let headers = field.headers();
        // println!("Name: {:?}, File Name: {:?}, Content Type: {:?}, Headers: {:?}", name, file_name, content_typers, headers);
        match content_typers {
            Some(cont) => {
                let conts = content_typers.clone().expect("NO CONTENT").to_string();
                let files = file_name.clone().expect("NO CONTENT").to_string();
                let substring : String;
                if let Some(pos) = files.rfind("\\"){
                    substring = (&files[pos + 1..]).to_string(); 
                    println!("Substring after last '\\': {}", substring);
                  }
                  else {
                        substring = files.clone();
                    }
                let heds = format!("{:#?}", headers.clone()).to_owned();
                // let files = format!("{:#?}", headers.get("filename").unwrap());
                // for key in headers.keys() {
                //     println!("{:?}", key);
                // }
                let bytes = field.bytes().await.unwrap();
                let strs= String::from_utf8_lossy(&bytes);
                // println!("Body String: {:#?}", strs);
                let newbody = "--".to_owned() + boundary + "\r\nContent-Disposition: form-data; name=\"file\"; filename=\""+ &substring +  "\"\r\nContent-Type: " + &conts  +  "\r\n\r\n" + &strs +  "\r\n--" + boundary + "--\r\n";
                // println!("newbody: {:#?}", newbody);
                // println!("newbody Bytes: {:#?}", newbody.clone().into_bytes());
                match process_attachment_scanningz(newbody.into_bytes(),content_type.clone(),config, cache, &client, service).await {
                    Ok(()) => {
                        logger::info!("Scanning {:?} successful, proceeding ", files);
                    }
                    Err(ScanningError::Infected(result)) =>{
                        logger::error!("Scanning {:?} detected an infected file : {:#?}", files, result);
                        return Err(ScanningError::Infected(result));
                    }
                    Err(ScanningError::ServerError(error)) =>{
                        logger::error!("Scanning {:?} Server returner unexpected error" , files);
                        return Err(ScanningError::ServerError(error));
                    }
                }
            }
            None => {
                logger::debug!("Skipping field as not file");
            }
        }

        // Process the field data chunks e.g. store them in a file.
        // while let Some(chunk) = field.chunk().await? {
        //     // Do something with field chunk.
        //     println!("Chunk: {:?}", chunk);
        // }
    }
    Ok(body)
}